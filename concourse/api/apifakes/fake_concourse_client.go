// This file was generated by counterfeiter
package apifakes

import (
	"sync"

	"github.com/concourse/atc"
	gc "github.com/concourse/go-concourse/concourse"
	"github.com/robdimsdale/concourse-pipeline-resource/concourse/api"
)

type FakeConcourseClient struct {
	DeletePipelineStub        func(pipelineName string) (bool, error)
	deletePipelineMutex       sync.RWMutex
	deletePipelineArgsForCall []struct {
		pipelineName string
	}
	deletePipelineReturns struct {
		result1 bool
		result2 error
	}
	ListPipelinesStub        func() ([]atc.Pipeline, error)
	listPipelinesMutex       sync.RWMutex
	listPipelinesArgsForCall []struct{}
	listPipelinesReturns     struct {
		result1 []atc.Pipeline
		result2 error
	}
	PipelineConfigStub        func(pipelineName string) (atc.Config, atc.RawConfig, string, bool, error)
	pipelineConfigMutex       sync.RWMutex
	pipelineConfigArgsForCall []struct {
		pipelineName string
	}
	pipelineConfigReturns struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}
	CreateOrUpdatePipelineConfigStub        func(pipelineName string, configVersion string, passedConfig atc.Config) (bool, bool, []gc.ConfigWarning, error)
	createOrUpdatePipelineConfigMutex       sync.RWMutex
	createOrUpdatePipelineConfigArgsForCall []struct {
		pipelineName  string
		configVersion string
		passedConfig  atc.Config
	}
	createOrUpdatePipelineConfigReturns struct {
		result1 bool
		result2 bool
		result3 []gc.ConfigWarning
		result4 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConcourseClient) DeletePipeline(pipelineName string) (bool, error) {
	fake.deletePipelineMutex.Lock()
	fake.deletePipelineArgsForCall = append(fake.deletePipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("DeletePipeline", []interface{}{pipelineName})
	fake.deletePipelineMutex.Unlock()
	if fake.DeletePipelineStub != nil {
		return fake.DeletePipelineStub(pipelineName)
	} else {
		return fake.deletePipelineReturns.result1, fake.deletePipelineReturns.result2
	}
}

func (fake *FakeConcourseClient) DeletePipelineCallCount() int {
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	return len(fake.deletePipelineArgsForCall)
}

func (fake *FakeConcourseClient) DeletePipelineArgsForCall(i int) string {
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	return fake.deletePipelineArgsForCall[i].pipelineName
}

func (fake *FakeConcourseClient) DeletePipelineReturns(result1 bool, result2 error) {
	fake.DeletePipelineStub = nil
	fake.deletePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourseClient) ListPipelines() ([]atc.Pipeline, error) {
	fake.listPipelinesMutex.Lock()
	fake.listPipelinesArgsForCall = append(fake.listPipelinesArgsForCall, struct{}{})
	fake.recordInvocation("ListPipelines", []interface{}{})
	fake.listPipelinesMutex.Unlock()
	if fake.ListPipelinesStub != nil {
		return fake.ListPipelinesStub()
	} else {
		return fake.listPipelinesReturns.result1, fake.listPipelinesReturns.result2
	}
}

func (fake *FakeConcourseClient) ListPipelinesCallCount() int {
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	return len(fake.listPipelinesArgsForCall)
}

func (fake *FakeConcourseClient) ListPipelinesReturns(result1 []atc.Pipeline, result2 error) {
	fake.ListPipelinesStub = nil
	fake.listPipelinesReturns = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourseClient) PipelineConfig(pipelineName string) (atc.Config, atc.RawConfig, string, bool, error) {
	fake.pipelineConfigMutex.Lock()
	fake.pipelineConfigArgsForCall = append(fake.pipelineConfigArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("PipelineConfig", []interface{}{pipelineName})
	fake.pipelineConfigMutex.Unlock()
	if fake.PipelineConfigStub != nil {
		return fake.PipelineConfigStub(pipelineName)
	} else {
		return fake.pipelineConfigReturns.result1, fake.pipelineConfigReturns.result2, fake.pipelineConfigReturns.result3, fake.pipelineConfigReturns.result4, fake.pipelineConfigReturns.result5
	}
}

func (fake *FakeConcourseClient) PipelineConfigCallCount() int {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	return len(fake.pipelineConfigArgsForCall)
}

func (fake *FakeConcourseClient) PipelineConfigArgsForCall(i int) string {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	return fake.pipelineConfigArgsForCall[i].pipelineName
}

func (fake *FakeConcourseClient) PipelineConfigReturns(result1 atc.Config, result2 atc.RawConfig, result3 string, result4 bool, result5 error) {
	fake.PipelineConfigStub = nil
	fake.pipelineConfigReturns = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeConcourseClient) CreateOrUpdatePipelineConfig(pipelineName string, configVersion string, passedConfig atc.Config) (bool, bool, []gc.ConfigWarning, error) {
	fake.createOrUpdatePipelineConfigMutex.Lock()
	fake.createOrUpdatePipelineConfigArgsForCall = append(fake.createOrUpdatePipelineConfigArgsForCall, struct {
		pipelineName  string
		configVersion string
		passedConfig  atc.Config
	}{pipelineName, configVersion, passedConfig})
	fake.recordInvocation("CreateOrUpdatePipelineConfig", []interface{}{pipelineName, configVersion, passedConfig})
	fake.createOrUpdatePipelineConfigMutex.Unlock()
	if fake.CreateOrUpdatePipelineConfigStub != nil {
		return fake.CreateOrUpdatePipelineConfigStub(pipelineName, configVersion, passedConfig)
	} else {
		return fake.createOrUpdatePipelineConfigReturns.result1, fake.createOrUpdatePipelineConfigReturns.result2, fake.createOrUpdatePipelineConfigReturns.result3, fake.createOrUpdatePipelineConfigReturns.result4
	}
}

func (fake *FakeConcourseClient) CreateOrUpdatePipelineConfigCallCount() int {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return len(fake.createOrUpdatePipelineConfigArgsForCall)
}

func (fake *FakeConcourseClient) CreateOrUpdatePipelineConfigArgsForCall(i int) (string, string, atc.Config) {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return fake.createOrUpdatePipelineConfigArgsForCall[i].pipelineName, fake.createOrUpdatePipelineConfigArgsForCall[i].configVersion, fake.createOrUpdatePipelineConfigArgsForCall[i].passedConfig
}

func (fake *FakeConcourseClient) CreateOrUpdatePipelineConfigReturns(result1 bool, result2 bool, result3 []gc.ConfigWarning, result4 error) {
	fake.CreateOrUpdatePipelineConfigStub = nil
	fake.createOrUpdatePipelineConfigReturns = struct {
		result1 bool
		result2 bool
		result3 []gc.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeConcourseClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeConcourseClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.ConcourseClient = new(FakeConcourseClient)
